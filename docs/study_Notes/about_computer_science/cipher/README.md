## 信息安全考前简记 <!-- {docsify-ignore} -->

在密码学中, RSA加密算法、乘法密码、仿射密码在解密时都会用到数论中模运算(Modulo Operation)的逆元. 下面整理一下数论中模乘运算的逆元的几种求法.

## 基本概念
### 1. 模运算
```
对于正整数 p 和正整数 a、b，定义如下运算：

取模运算 ： a % p (或 a mod p)，表示 a 除以 p 的余数。
模 p 加法：(a + b) % p，其结果是 a + b 算术和除以 p 的余数。
模 p 减法：(a - b) % p，其结果是 a - b 算术差除以 p 的余数。
模 p 乘法：(a * b) % p，其结果是 a * b 算数积除以 p 的余数。
同余式：正整数 a、b 对 p 取模，他们的余数相同，记作 a ≡ b (mod p)。  

说明：
n % p 得到结果的正负由被除数 n 决定，与 p 无关。
例如：7 % 4 = 3, -7 % 4 = -3, -7 % -4 = -3.

运算规则
模运算与基本四则运算有些相似，但是除法除外。其规则如下：
(a + b) % p = (a % p + b % p) % p
(a - b) % p = (a % p - b % p) % p
(a * b) % p = (a % p * b % p) % p
a ^ b % p = ((a % p) ^ b) % p
结合律
((a + b) % p + c) % p = (a + (b + c) % p) % p
((a * b) % p * c) % p = (a * (b * c) % p) % p
交换律
(a + b) % p = (b + a) % p
(a * b) % p = (b * a) % p
分配律
(a + b) % p = (a % p + b % p) % p
重要定理
若 a ≡ b (mod p)，则对于任意的 c，都有(a + c) ≡ (b + c) (mod p)
若 a ≡ b (mod p)，则对于任意的 c，都有(a * c) ≡ (b * c) (mod p)
若 a ≡ b (mod p)，c ≡ d (mod p)，则有:
(a + c) ≡ (b + d) (mod p)
(a - c) ≡ (b - d) (mod p)
(a * c) ≡ (b * d) (mod p)
```

### 2. 逆元
逆元是数论中的概念, 在离散数学中也学习过.

定义   
逆元是群G中任意一个元a，都在G中有唯一的逆元a'，具有性质 a · a' = a' · a = e ( · 为该群中定义的某运算), 则a和a'互为逆元.

其中，e为该群的单位元(又称幺元). 单位元是集合里的一种特别的元素，与该集合里的二元运算有关。当单位元和其他元素结合时，并不会改变那些元素。


在模p乘法运算中，单位元显然是1。这是因为群G中只含 0 到 p-1 共 p 个整数, 其中任何一个数和1相乘后都不改变其本身.

通俗的理解, 逆元其实是加法中的相反数以及乘法中的倒数的拓展思想。a的逆元便是可以使 a * a' mod p = 1 的最小a'。


## 求逆元的方法

- 枚举法
- 利用拓展欧几里得算法求解同余方程
- 费马小定理等拓展方法

### 1. 枚举法
```
枚举试凑1到p - 1的整数bi，若b * bi % p = 1，则bi即为b mod p的乘法逆元。

为什么只枚举到p - 1呢？

1. 如果枚举到 p，那么显然 b * p % p = 0；

2. 如果枚举到 p + k ，那么有 b * (p + k) % p = b * p % p + b * k % p = b * k % p，这样就返回了枚举1到p - 1的情况；

3. 从群论的角度, 逆元是G中某元素. G中最大的元素就是p-1, 逆元一定在1到 p-1 之间, 所以无需继续枚举.

```
!> 如果p是一个强质数, 也就是说p太大, 枚举法就不太好用了. 于是用拓展欧几里得算法递归求解逆元.

### 2. 拓展欧几里得(Extend - Eculid)
#### 2.1 最大公约数
最大公约数（Greatest Common Divisor，简称 GCD）是指两个整数所能被同时整除的最大正整数。换句话说，如果有两个整数 a 和 b，那么它们的最大公约数是它们共有的公约数中最大的那个。  

值得注意的是, 这两个整数可以是正数, 也可以是负数. 负数的最大公约数与其绝对值的最大公约数相同, 即:  
**gcd{𝑎,𝑏}=gcd{−𝑎,𝑏}=gcd{𝑎,−𝑏}=gcd{−𝑎,−𝑏}**


#### 2.1 欧几里得算法
欧几里得算法(Euclidean Algorithm), 又叫辗转相除法, 是一个古老且高效的方法，用于求解两个整数的最大公约数。

欧几里得算法基于以下性质：  
对于任意的两个整数 a 和 b (a > b)，有**gcd(a, b) = gcd(b, a % b)。**  
其中, gcd(a,b)表示正整数a和b的最大公约数. a % b 表示a对b取模运算的结果.

<!-- Python 语言实现：

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

a = 99
b = 78
result = gcd(a, b)
print("gcd({0}, {1}) = {2}".format(a, b, result)) -->

C++ 代码实现:
```C++
int gcd(int a, int b) {
    // 当 b 为 0 时， a 就是最大公约数
    if (b == 0) {
        return a;
    }
    // 递归调用 gcd 函数，用 b 和 a % b 作为参数
    return gcd(b, a % b);
}
```
<!-- <iframe src="//player.bilibili.com/player.html?aid=717731278&bvid=BV1KQ4y127AT&cid=399440988&page=1" height="500" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe> -->
> 欧几里得算法的几何表示和证明过程都很简单, 故略去. 详细可参考: https://www.bilibili.com/video/BV19r4y127fu

#### 2.2 拓展欧几里得定理求逆元

##### 2.2.1 拓展欧几里得定理

扩展欧几里得定理（Extended Euclidean Algorithm）是欧几里得算法的一个扩展，用于求解贝祖等式（Bézout's identity, 也称为裴蜀等式）。贝祖等式是形如 ax + by = gcd(a, b) 的线性方程，其中 a 和 b 是已知的整数，x 和 y 是需要求解的整数，gcd(a, b) 是 a 和 b 的最大公约数。特殊地, 当 x 和 y 互质时, 等式右部等于1.

扩展欧几里得算法的基本思路是使用递归，从最大公约数的性质出发，将问题逐步简化。具体步骤如下：

- 若 b=0，则 gcd(a, b) = a。此时 x=1, y=0。
- 否则，运用递归求解贝祖等式：(a % b) * x + b * y = gcd(b, a % b)。由于 gcd(a, b) = gcd(b, a % b)，我们可以将问题规模缩小，递归求解 x' 和 y'。
- 通过 x' 和 y' 计算 x 和 y： x = y'，y = x' - (a // b) * y'。

##### 对以上步骤的解释:  
在扩展欧几里得算法中，我们想要找到一对整数 x 和 y，使得 ax + by = gcd(a, b)。我们利用欧几里得算法（辗转相除法）来求解最大公约数，同时计算出 x 和 y。

当我们递归地应用欧几里得算法时，每次递归都缩小了问题的规模。在每一步中，我们需要找到一对新的 x 和 y，使得它们满足 ax + by = gcd(a, b)。我们已经找到了一对整数 x' 和 y'，使得 bx' + (a % b)y' = gcd(b, a % b)。现在，我们需要通过 x' 和 y' 来计算 x 和 y。

我们知道 a % b = a - (a // b) * b。所以我们可以将 (a % b) 替换为 a - (a // b) * b：

bx' + (a - (a // b) * b)y' = gcd(b, a % b)

我们的目标是找到 x 和 y，使得：

ax + by = gcd(a, b)

根据狭义欧几里得定理, 可以发现, 上面两个等式的右部是相等的, 于是它们的左部也相等:

ax + by = bx' + (a - (a // b) * b)y'

为了满足这个条件，我们可以将 x 设置为 y'，将 y 设置为 x' - (a // b) * y', 即:

x = y'
y = x' - (a // b) * y'

这样就得到了扩展欧几里得算法中x和y的更新规则。通过递归地应用这个规则，可以找到满足 ax + by = gcd(a, b) 的整数 x 和 y。
##### C++代码实现：
```C++
// 已知正整数a和b, 求解满足等式ax+by=1中, x和y的一组最小整数解.
long ExpGcd(long a, long b, long &x, long &y) {
    long q, temp;
    if( b==0 ) { // b=0时跳出递归, 若 b=0，则 gcd(a, b) = a。此时 x=1, y=0。
        q = a; 
        x = 1; 
        y = 0;
    }else {
        q = ExpGcd(b, a % b, x, y); // (a%b)*x'+b*y'=gcd(b,a%b)
        temp = x; 
        x = y;
        y = temp - (a / b) * y; // 通过x'和y'计算x和y：x=y'，y=x'-(a//b)*y'
    }
    return q;
}

```
##### 2.2.2 求逆元的方法

当a和b互质时, gcd(a,b)=1, 于是ax+by=1可化为:
- ax = 1 - by
- ax = 1 + b*(-y), 令y<0, 则(-y)>0
- ax = 1 (mod b)

于是x和a互为逆元. 给定a、b, 利用上述方法解方程 ax + by = 1, 得到x即可.  

**上述求逆元的方法, 可以用在RSA加密算法中密钥的生成.**

## RSA加密算法
RSA算法的基本步骤如下：

- 选择两个大素数 p 和 q。这两个素数越大，加密过程越安全，但计算复杂度也会相应增加。

- 计算乘积 n = p * q。n 用于确定公钥和私钥的模数，其位数决定了加密过程的安全性。

- 计算欧拉函数 φ(n) = (p-1) * (q-1)。φ(n) 用于生成公钥和私钥。

- 选择一个整数 e，使得 1 < e < φ(n)，且 e 和 φ(n) 互质。通常情况下，会选择一个较小的质数，如 3 或 65537。

- 计算 d，使得 (d * e) % φ(n) = 1。换句话说，d 是 e 在模 φ(n) 下的乘法逆元。

- 至此，已经生成了一对密钥：公钥为 (e, n)，私钥为 (d, n)。



<!-- 求最小整数x、y，使 x * a + y * b = gcd(a , b)；

类似这样的问题便可以使用拓展欧几里得来求解。

由欧几里得定理可知gcd(a , b) = gcd(b , a % b) (假设 a > b)，

所以有x' * b + y' * (a % b) = gcd(a , b)，假设已经求得 x' 和 y'，那么有 ：

∵ x' * b + y' * ( a % b) = gcd(a , b) and a % b = a - [a / b] * b

∴ x' * b + y' * ( a - [a / b] * b) = gcd(a , b)

∴ y' * a + (x' - y' * [a / b]) * b = gcd(a , b)

如此这个问题便可以递归的求解了。

（显然如果b = 0的话，那么x = 1，y = 0）

那么求解 b' 使得 b * b' mod p = 1 这个问题便可以转化为：

求最小整数 b'、k，使得 b' * b + k * p = 1； -->





### 例题
!> 例题: 设p=43, q=59, n = p*q = 43 * 59 = 2537, φ(n)=(p-1) * (q-1), 取e=13, 求e的逆元d.
```
φ(n) = 2436, 因此解方程: d*13 = 1 mod 2436, 求d即可.
法一: 枚举法试凑
13*d = k*2436 + 1 从1开始不断增加k的值, 最终可求出d=937, 但计算较为困难.
法二: 扩展欧几里得算法
-2436*k + 13*d = 1 此式中, 左边 = gcd(k,d) = gcd(-k,d);
因此可令 x=-k, 左式变为 2436k + 13d, 右式不变仍为1, 即求解:
2436x + 13y = 1 (1)
  13x +  5y = 1 (2)
   5x +  3y = 1 (3)
   3x +  2y = 1 (4)
   2x +   y = 1 (5)
    x +  0y = 1 (6)
(6)式中令 x=1 y=0, 即:
x'= 1 y'= 0, 回溯(5), 得: x=y'= 0 y=x'-[a/b]*y'=  1 ([x]表示对x向下取整)
x'= 0 y'= 1, 回溯(4), 得: x=y'= 1 y=x'-[a/b]*y'= -1
x'= 1 y'=-1, 回溯(3), 得: x=y'=-1 y=x'-[a/b]*y'=  2
x'=-1 y'= 2, 回溯(2), 得: x=y'= 2 y=x'-[a/b]*y'= -5
x'= 2 y'=-5, 回溯(1), 得: x=y'=-5 y=x'-[a/b]*y'=937

```
**解得d=937为所求.**
> [关于逆元的更多拓展知识](https://zhuanlan.zhihu.com/p/449221995)
